## [04장 - 변수]

### _변수란 무엇인가? 왜 필요한가?_

- 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념
- 컴퓨터
  - CPU 사용 -> 연산
  - 메모리 사용 -> 데이터 기억
  - 1바이트 단위로 데이터를 write (저장), read (읽기)
  - 모든 데이터를 2진수로 처리함
- JS - 개발자의 직접적인 메모리 제어 허용 X <br/>
  (메모리 주소를 통해 값에 직접 접근하는 것은 치명적 오류 발생 가능 <br/>
  ex) OS 환경변수 값 변경)
- 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수 사용
- 변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 <br/>
  또는 그 메모리 공간을 식별하기 위해 붙인 이름 <br/>
  (값의 위치를 가리키는 상징적인 이름, 변수 -> 메모리 공간 주소 치환)
- 변수를 통해 안전하게 값에 접근 가능
- 변수에 저장된 값의 의미를 파악할 수 있는 변수 이름 => 가독성 높임

### _식별자_

- 변수 이름
- 메모리 공간에 저장되어 있는 어떤 값을 구별해서 식별할 수 있는 고유한 이름
- 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)하고 있음
- 값이 아니라 메모리 주소 기억
- 메모리 주소에 붙인 이름
- 변수, 함수, 클래스 등 모든 이름
- 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름
- 네이밍 규칙 준수

### _변수 선언_

- 변수 생성
- 값을 저장하기 위한 메모리 공간을 확보 (allocate), <br/>
  변수 이름과 확보된 메모리 공간의 주소를 연결 (name binding) 해서 <br/>값을 저장할 수 있게 준비하는 것
- 변수 사용하기 위해 반드시 사전에 변수 선언 필요!
- `var`, `let`, `const` 키워드 사용
- `var`
  - 뒤에 오는 변수 이름으로 새로운 변수 선언을 지시하는 키워드
  - `var score;` <br/>
    변수 선언 이후 아직 값 할당 X, `undefined` 라는 값이 암묵적으로 할당되어 초기화 됨 <br/>
    (=> 이전 쓰레기 값 참조할 위험 방지 가능)
  - 변수 선언 단계, 변수 초기화 단계 동시 진행

### _변수 선언의 실행 시점과 변수 호이스팅_

- 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점 (runtime) 이 아니라 <br/>
  그 이전 단계에서 먼저 실행됨
- JS 엔진 - 소스코드 한 줄씩 순차적 실행 전에 소스코드 평가 과정을 거치면서 <br/>
  소스코드를 실행하기 위한 준비를 함
- JS 엔진의 평가 과정 - 변수 선언문, 함수 선언문 등 모든 선언문을 먼저 실행 <br/>
  => 변수 선언이 소스코드 어디에 위치하든지 상관 없이 어디서든지 변수 참조 가능
- <u>변수 호이스팅</u>: 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징 😆
- 모든 선언문은 런타임 이전 단계에서 먼저 실행됨

### _값의 할당_

- 할당 연산자 `=` 사용
- `var` 키워드 사용 시 변수의 선언과 할당을 하나의 문으로 단축 표현 가능 <br/>

  ```js
  var score;
  score = 80;

  // 단축 표현
  var score = 80;
  ```

- JS 엔진은 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행함

- 변수 선언과 값의 할당의 실행 시점이 다름 <br/>
  => 변수 선언은 런타임 이전에 먼저 실행되지만 <br/>
  값의 할당은 런타임 시점에 실행됨 😮

- 변수에 값을 재할당 할때, 이전 값이 저장되어 있는 메모리 공간을 지워서 거기에 저장하는 것이 아니라 <br/>
  새로운 메모리 공간을 확보하고 그곳에 새로운 할당값을 저장하는 것임

```js
console.log(score); // undefined

var score; // 1. 변수 선언
score = 80; // 2. 값의 할당

console.log(score); // 80
```

```js
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // ?? => Ask the computer! (80)
```

### _값의 재할당_

- 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것
- `var` 키워드로 선언한 변수는 값의 재할당 가능
- 변수에 저장된 값을 다른 값으로 변경 가능 (변수) <br/>
  값의 재할당이 불가능하여 변수에 저장된 값을 변경할 수 없으면 상수임

`const` 키워드를 사용하여 선언한 변수

- 값의 재할당 불가
- 상수 (변하지 않는 수) 표현 가능

### _식별자 네이밍 규칙_

- 특수문자를 제외한 문자, 숫자, \_, $만 포함 가능
- 숫자로 시작할 수 없음
- strict mode 에서 예악어를 식별자로 사용 불가

- 변수 이름도 식별자 네이밍 규칙 따름
- 식별자 네이밍 규칙 위배하면 SyntaxError 발생
- JS는 대소문자 구분함
- 좋은 변수의 이름은 코드의 가독성을 높임 <br/>
  (변수 선언에 별도의 주석이 필요하다 <br/>
  => 변수의 존재 목적을 명확히 드러내지 못하는 것)

- 네이밍 컨벤션
  - camelCase (JS - 변수나 함수)
  - snake_case
  - PascalCase (JS - 생성자 함수, 클래스)
  - typeHungarianCase

#

## [Note]

### _참고 개념_

- 메모리: 데이터를 저장할 수 있는 메모리 셀의 집합체
- 메모리 셀 하나 크기 - 1byte (8 bit)
- 각 셀은 고유의 메모리 주소를 가짐 (메모리 공간의 위치)
- 메모리에 저장되는 모든 값은 2진수로 저장됨
- 연산 결과도 메모리 상의 임의의 위치에 저장됨
- 값이 저장될 메모리 주소는 코드가 실행될 때 메모리 상황에 따라 임의로 결정됨
- JS에서 함수는 값임
- `var` : block-level scope 지원 X, function-level scope 지원 <br/>
  (전역 변수가 선언되는 심각한 부작용 초래)
- ES6는 ES5의 superset (상위 집합) <br/>
  (ES6는 하위 호환성을 유지하면서 ES5 기반 위에 새로운 기능 추가)
- 키워드 (JS 엔진이 수행할 동작을 규정한 일종의 명렁어)
- undefined (JS에서 제공하는 primitive value)
- 실행 컨텍스트 (execution context) <br/>

  (모든 식별자는 여기에 등록됨, JS 엔진이 소스코드를 평가하고 실행하기 위해 <br/>
  필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역) <br/>

- JS 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리함
- 변수 초기화: 변수가 선언된 이후 최초로 값을 할당하는 것
- ReferenceError (선언하지 않은 식별자/변수에 접근하면 발생하는 에러)
- JS 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행됨
- 런타임 시점 (소스코드가 순차적으로 실행되는 시점)
- 재할당 (변수에 이미 값이 할당되고 이후 새로운 값이 할당되는 행위)
- 상수는 단 한 번만 할당할 수 있는 변수임
- 값의 할당/재할당이 일어나는 순간 그 식별자/변수는 할당/재할당 되는 값이 들어있는 <br/>
  새로운 메모리 주소 공간을 가리키게 됨 <br/>
  (기존의 메모리 공간에 들어있는 값을 대체하는 것이 아님)
- JS는 G.C를 내장하고 있는 managed 언어임 <br/>
  G.C를 통해 메모리 누수 방지, 일정한 생산성 확보 가능 <br/>
  but, 성능 면에서 어느 정도 손실을 감수해야 함

### _용어_

- literal (값)
- expression (표현식, 식)
- parsing (해석)
- operand (피연산자), operator (연산자)
- assignment (할당, 대입, 저장)
- reference (참조)
- identifier (식별자)
- declaration (선언)
- allocate (확보)
- binding (연결)
- release (해제)
- deprecated (폐기)
- primitive type (원시 타입)
- initialization (초기화)
- garbage value (쓰레기 값)
- ReferenceError (참조 에러)
- statement (문)

#

## _[Questions]_

1. 예약어 뒤에 \* 붙어 있는 것은 무슨 의미지?

2. G.C의 장점인 메모리 누수가 정확히 무슨 뜻일까?

3. 호이스팅의 정확한 뜻은 무엇일까?

## _[Solved]_

1. [딥 다이브 42 페이지 4.4절] <br/>
   모든 선언문은 JS 엔진의 평가 과정에서 먼저 실행되는데, <br/>
   **선언적 함수 vs. 익명 함수**에서 선언적 함수도 전체 코드를 <br/>
   한 줄씩 읽어 나가기 이전에 평가 과정에서 먼저 선언되는데, <br/>
   익명 함수의 경우에는 보통 const로 선언한 변수에 할당하여 사용하는데 <br/>
   그 경우에는 변수 선언이므로 변수 호이스팅으로 적용이 되는건가요?<br/>
   익명 함수의 실행되는 모습을 보면 그러지는 않은 것 같습니다.. <br/>

   => 변수 선언은 런타임 이전 소스코드 평가 과정에서 먼저 실행되지만, <br/>
   값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행됨!

#

[Reference](https://wikibook.co.kr/mjs/)
