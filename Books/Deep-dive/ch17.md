## [17장 - 생성자 함수에 의한 객체 생성]

### _Object 생성자 함수_

- 생성자 함수: new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수
- 생성자 함수에 의해 생성된 객체 => 인스턴스

### _생성자 함수_

- 객체 리터럴에 의한 객체 생성 방식의 문제점
  - 직관적이고 간편하지만, <br/>
    단 하나의 객체만 생성함
  - 동일한 프로퍼티를 갖는 객체를 여러 개 생성 시 매번 같은 프로퍼티 기술 <br/>
    => 비효율적 (수십 개의 객체 생성 힘듦)
- 생성자 함수에 의한 객체 생성 방식의 장점
  - 프로퍼티 구조가 동일한 객체 여러 개 간편하게 생성 가능
  - 생성자 함수
    - 객체(인스턴스)를 생성하는 함수
    - 일반 함수와 동일한 방법으로 생성자 함수 정의
    - new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작
- 생성자 함수의 인스턴스 생성 과정
  - 생성자 함수의 목적; 인스턴스 생성, 생성된 인스턴스 초기화 <br/>
    (인스턴스 프로퍼티 추가 및 초기값 할당)
  - JS 엔진은 암묵적으로 인스턴스 생성, 초기화, 반환의 과정 수행
  - 인스턴스 생성과 this 바인딩
    - JS 엔진 평가 과정에서 암묵적으로 빈 객체가 생성됨 <br/>
      (생성자 함수가 생성한 인스턴스) <br/>
      이후 빈 객체 (인스턴스)가 this에 바인딩됨
  - 인스턴스 초기화
    - 개발자 기술; this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드 추가
  - 인스턴스 반환
    - 인스턴스가 바인딩 된 this가 암묵적으로 반환됨
    - 명시적으로 객체를 반환하면 암묵적인 this 반환이 무시됨 <br/>
      명시적으로 원시 값을 반환하면 암묵적으로 this가 반환됨
    - return 문 반드시 생략
- 내부 메서드
  - [[Call]] 과 [[Construct]]
    - 함수는 객체이다
    - 일반 객체는 호출할 수 없지만 함수는 호출 가능
    - 일반적인 함수로서 호출: [[Call]] 이 호출됨
    - 생성자 함수로서 호출: [[Construct]] 가 호출됨
    - 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출은 불가
  - constructor와 non-constructor의 구분
    - 일반 함수 정의: 함수 선언문, 함수 표현식
    - 일반 함수로 정의된 함수만이 constructor
    - 화살표 함수, 메서드 축약 표현 => non-constructor
  - new 연산자
    - 생성자 함수는 일반적으로 파스칼 케이스 사용
  - new.target
    - 메타 프로퍼티
    - new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가리킴
    - new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined

#

### [Note]

- 객체 생성 방식: 객체 리터럴 vs. 생성자 함수
- Function 생성자 함수에 의한 객체(함수) 생성
- 객체
  - 프로퍼티를 통해 객체 고유의 상태 표현 (프로퍼티 === 상태 데이터)
  - 메서드를 통해 프로퍼티 참조, 조작하는 동작 표현
- `this` (객체 자신의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수)
  - this 바인딩
    - 함수 호출 방식에 따라 동적으로 결정됨
    - 일반 함수 호출; 전역 객체 (this가 가리키는 값, this 바인딩)
    - 메서드 호출; 메서드 호출한 객체
    - 생성자 함수 호출; 생성자 함수가 미래에 생성할 인스턴스
- 바인딩; 식별자와 값 연결
- 스코프 세이프 생성자 패턴
  - 프로토타입, instanceof 연산자

#

[Reference](https://wikibook.co.kr/mjs/)
