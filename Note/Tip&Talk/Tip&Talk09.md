## {풀스택} JavaScript 9강 - 컴파일 언어/인터프리터 언어/도메인/컨텍스트/스코프/this

### _컴파일 언어_

- 컴파일 -> 기계어
- Java; 컴파일 -> 바이트코드 -> 기계어
- 컴파일; 메모리 위치와 사이즈 잡음 (타입이 정해져 있음)
- C언어는 string 타입 없고 포인터 이용 => char\* (포인터는 실제로 메모리의 위치임)
  - 컴파일 할때 1바이트로 잡음
  - 메모리 위치만 잡음 (얼마나 올지 모름)
  - 데이터는 heap 영역에 있음

### _인터프리터 언어_

- 컴파일 없음, 대신에 평가를 함, 이후 실행
- JS는 인터프리터 언어
- 타입을 모르므로 메모리 사이즈 처음에 안잡음
  - 실행을 해봐야 사이즈 얼마인지 알 수 있음
  - 메모리 위치는 잡을 수 있지만 사이즈는 미리 못잡음
- 소스코드 돌릴 때 평가도 하고 실행도 하고 시간 많이 걸림

### _도메인_

- 우리의 도메인; CS - 프로그래밍 (넓은 영역)

### _컨텍스트_

- 컨텍스트; 프로그래밍 스터디

### _스코프_

- 스코프; SSAC 아카데미 공간
- 스코프가 다르면 서로 접근 불가

### _this_

- JS 엔진이 평가 과정에서 읽으면서 전역 변수에 대한 인스턴스 생김
- JS 엔진이 평가 시 메모리 위치 잡음 => 인스턴스는 메모리 속의 객체 자기 자신
- my instance => 스코프에 따라 다름 (실행 컨텍스트)
  - 전역 코드
    - 평가; 함수 위치만 잡아 놓음, 아직 함수 내부 코드 평가/실행 안함 <br/>
      함수 호출했을 때 함수 내부 코드 평가 시작
  - 함수
  - 블록 (ES6 부터 생김; const/let)
  - 모듈
- 일반 함수; new로 안부르는 함수
  - this: 전역 window (global, globalThis)
  - 윈도우가 아니라 외부 변수 가리키고 싶으면 <br/>
    일반 함수 호출할 때 this 해당 객체를 주면 됨 <br/>
    => f.bind(a); // f 함수 내부의 this는 외부에서 준 변수에 해당 <br/>
    하지만 바로 호출은 안됨, f()로 또 불러야 함 <br/>
    만약 호출 동시에 하고 싶으면, apply() 또는 call() 이용 <br/>
    f.apply(a, [1, 2]) // 배열로 줌 (argument) <br/>
    f.call(a, 1, 2) // 그냥 펼쳐서 줌 (argument)
  - 다형성 같음
- 생성자 함수; new로 부르는 함수
  - this: 인스턴스 (미래 생성될)
- 화살표 함수;
  - OuterLexicalEnvironmentReference; 외부 참조 (부모만 참조)
    - 상위 스코프 참조
  - 먼저 나한테 있는지 확인 -> 바깥쪽 확인 -> 윈도우 객체 확인 (윈도우 프로토타입)
  - 평가 전에 이미 window 객체 다 만들어 놓고 시작함
  - 일반 함수의 this는 바깥쪽 윈도우 객체
  - window 객체에 name 이미 정의되어 있음 (HTML 타이틀 - 창 이름)
  - 만약 상위 스코프 참조하고 싶으면 화살표 함수 이용! (바로 상위 인스턴스 가리킴)
  - 항상 화살표 함수 사용!
- document.addEventListener('click', function(event) {})
  - 클릭했을 때 실행됨 => 콜백함수는 전역함수가 아님
  - click 이벤트는 document에 종속됨
  - 하지만 document가 클릭된 객체 찾아줌 ex) 택배가 옴 => 그 해당 방 (경비실에서 받기는 하지만..)
  - 콜백함수 내부의 this는 그 이벤트 달린 객체
  - 헷갈리므로 event.target 사용함!
  - 만약 외부 변수 가지고 오고 싶으면 화살표 함수 사용
    - 만약 이벤트 달린 객체 접근하고 싶으면 event.target으로 접근
    - 보통 바깥 변수 가리키는 경우 많으므로 화살표 함수 사용함
- 일반함수, 생성자 함수, 이벤트 리스너 함수에 따라 다 다름

### [Note]

- SW에서 코드가 실행될 떄 가장 부담스러운 것은 메모리 확보 (비용 가장 많이 듬)
  - 컴파일러는 미리 공간 잡음 => 실행 훨씬 빠름 (인터프리터 보다)
- 현재는 하드웨어 많이 발전해서 명령형 보다는 선언형 선호
- TV, 냉장고, 세탁기 등은 H/W가 상대적으로 약해서 low level 언어로 소스코드 짜야함
- var는 function level scope, const는 block level scope
- 클래스는 함수임
  - 예시) a = new A();
    - 생성자 함수 호출했을 때 그 클래스 내부 코드 평가 시작
    - 함수(클래스) 실행 컨텍스트에 실제로 인스턴스 생기고 a (전역에 있는 변수)가 그 인스턴스 참조
    - function도 object임, primitive type 아니면 다 참조
- 평가 단계에서 함수의 상위 함수(스코프)와 전역 스코프에 대한 포인터 2개 잡음
  - 메모리 위치만 잡음, 아직 사이즈는 모름

#

[Reference](https://www.youtube.com/watch?v=3aQiY2FCJHU&ab_channel=%EC%8B%9C%EB%8B%88%EC%96%B4%EC%BD%94%EB%94%A9)
