## [21_08_24 화 Zoom 온라인 수업 3]

### _공지사항_

- 과제

  - 과제 제출에 대한 가산점 기준 없앰
  - 제출 기한은 다음 오프라인 수업 전까지
  - 과제는 지혜님께 제출

- 몇 가지 책 소개해주심

  - 그 책들에 대한 질문 가능

- 9월 일정 (9월 2일 목요일부터 적용)

  - 화/목 1500~2100 (오프라인) <br/>
    1500 ~ 1900은 자율, 본 수업은 1900 ~ 2100 <br/>
    지혜님은 풀타임, 멘토님은 18시 이전에 오심 <br/>
    (3층 파트너스 질문 or 함께 공부 가능)
  - 매주 목요일 코드 리뷰 예정
  - 토요일은 온라인 수업 (줌 or slack으로 개인 질문 가능) <br/>
    (11월부터라도 포트폴리오 준비 시 오프라인도 협의 노력)
  - 절대 취식 금지, 물은 텀블러 활용해서 가능

- 스터디
  - 팀 프로젝트 시 프로젝트 관련 기술들로 스터디 가능

### _본수업_

- 지난 시간
  - 옵셔널 체이닝, null 병합 연산자 꼭 기억!
- 10장 - 객체 리터럴
  - 함수, 배열, 정규표현식 등 모두 객체 리터럴
  - 객체는 JS 엔진에 의해 평가되고 실행되면 바로 인스턴스임
  - object의 method(함수)는 콜론 안붙이고 바로 메서드이름(){} 가능
  - 변수 이름과 프로퍼티 이름이 같으면 하나만 써도 됨
  - {...변수} (복제)
- 11장 - 원시 값과 객체의 비교
  - JS는 동적 타이핑 언어; 쓰기가 빠름 <br/>
    (정적 타입은 확장 떄문에 쓰기가 느림)
  - primitive type은 immutable
  - string은 byte 별로 쪼개져 있어서 객체처럼 유사하게 활용 가능 (ex. 인덱싱)
  - 얕은 복사 vs. 깊은 복사
    - 얕은 복사 시 속은 복사 안하고 겉까지만 복사함 <br/>
      겉 참조 주소는 다르지만 속 참조 주소는 같음 <br/>
      (속 값이 바뀌면 메모리 큰 낭비될 수 있음, 속은 같은 주소 참조 => 효율적)
    - 깊은 복사는 통째로 복사해서 별도 공간의 메모리 모두 할당
  - object 비교는 메모리 주소 비교, primitive type은 값 비교

#

### [과제]

- 필수
  - 개인 과제형 - To Do 앱 발전형 (트렐로, 개인 일정 관리) <br/>
    계속 발전시켜 나갈 것임, node 서버 연동 <br/>
    토요일 투표 예정 <br/>
    1안) 중요/긴급 업무 테스크 4분할, 팀 프로젝트 (트렐로 확장)<br/>
    2안) 중요/긴급 4분할, 크롬 여러 탭 링크 만들어서, <br/>
    링크 하나 (탭) 클릭해서 다 봤으면 없애고,... 북마크 같은 사이트 <br/>
    => 토요일에 프로젝트 정해서 DB 설계 맞춰서 바로 진행할 예정
  - 수업 프로젝트 - 부동산 앱? or 다른 것 고민중이심
  - 팀 프로젝트 (포트폴리오)
- 자율

  - 개인 토이 프로젝트

- 숫자 야구 게임 코드 리팩토링 후 지혜님께 링크 제출

  - input history 필요할 듯

- MySQL DB 모델 설계 기법 (실무 설계 영상 참고) => 다음주 토요일 과제 진행 예정

- 토요일 얕은 복사 vs. 깊은 복사 보충 설명 예정

#

### [Note]

- 아는 것이랑 설명하는 것은 다름
- 트렐로: 프로젝트 테스크 관리
- 리터럴: 값으로 표현되는 것
- 멤버 변수 => 프로퍼티, 멤버 함수 => 메서드
- JSON은 키가 숫자여도 가능
- Hash <br/>
  object에서 동일한 프로퍼티의 키에 값을 재할당 하면 기존 값 뭉개짐 (overwrite) <br/>
  Map, Set 도 모두 hash임 (자료구조) <br/>
- Hash와 Hash table 용어 다름 <br/>
  Hash table은 키 값을 hashing 함 <br/>
  index로는 해결 안됨 (일일이 다 찾으러 가야 함) <br/>
  키는 보통 string으로 두고 값에는 주소값이 있음 <br/>
  값에 주소가 아니라 실제 data를 넣고 싶으면 string으로 변환해서 들어감 <br/>
  JSON: JSON.stringify() <br/>
  보통 키를 가지고 hash() 함수를 돌림 (JS 엔진마다 구현 함수 다름) <br/>
  => unique한 값이 나옴(주소), 해시 함수 돌려서 주소 바로 찾아갈 수 있음 <br/>
  (키의 순서를 해시함수로 돌린 것으로 배치함, 해시 함수 결과값은 알 수 없음, <br/>
  해시 함수 결과는 항상 동일하게 세팅, 암호화 알고리즘 (ex. 64진수))
- Redis 같은 memory cache도 모두 key-value 쌍
- Java, C 같은 언어는 컴파일 떄 미리 메모리를 확보해놓고 구동시킴 <br/>
  넉넉하게 큰 메모리 (힙), 만약 메모리 초과하면 메모리 full/stack overflow/nullpointer 등 에러 발생함
- node도 메모리 미리 확보해 놓고 js 파일 구동 <br/>
  해시 알고리즘을 적용하여 각 메모리 주소 범위에 맞는 곳으로 집어 넣음
- Map, Set 모두 key 중복 안됨
- node로 실행하는 것은 readline이라는 것이 있음 <br/>
  (HTML 파일 없이 터미널로 구동 가능)

  ```js
  const readline = require('readline');
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  rl.on('line', function (line) {
    console.log('hello !', line);
    rl.close();
  }).on('close', function () {
    process.exit();
  });
  ```
