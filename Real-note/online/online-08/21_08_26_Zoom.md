## [21_08_26 목 Zoom 온라인 수업 4]

### _본수업_

- 오늘 12장만 진행할 예정 (함수 파트)
- 함수; parameter, argument
- JS 엔진이 함수를 평가하는데 겉만 평가함 (속까지는 평가하지 않음)
- 값이 함수임 => 함수 리터럴
- 함수도 객체임
- ES6부터는 함수 표현식을 사용하는데 대부분 화살표 함수 사용함
- console 프로토타입에는 여러 속성과 메서드가 있음
- 표현식이 아닌 건 리터럴이 아니고 그건 값이 아니고 그 자체가 object임
- 선언적 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다름 <br/>
  인스턴스화 되는 시점, 메모리 잡히는 시점, 실행 컨텍스트에 등록되는 시점
- 호이스팅이란?
  - 변수 호이스팅
  - 함수 호이스팅
    - 함수 선언문
    - 함수 표현식 => 변수 호이스팅에 속함
- new Function()은 클로저 생성하지 않음 <br/>
  속에 변수가 다 선언되어 있어야 함
- 화살표 함수
- 함수가 갖는 인수들을 array로 만듦 (arguments)
- 콜백 함수; 매개변수로 함수를 전달
- 비동기 I/O (non block I/O) => 콜백 함수 사용
- 바깥 데이터 다 조작하면 비순수 함수임
- 화/목 수업 영상 녹화 => 토요일 복습

#

### [Q&A]

- 리터럴 vs. 표현식

#

### [Note]

- new 연산자를 이용하여 instance화 하기
- AWS 람다; 스트링이 코드가 되는 reflection
  - reflection; 코드는 실행하기 전까지는 문자일뿐 <br/>
    하지만 실행하게 되면 메모리에 객체로 잡힘 <br/>
    문자 <-> 객체 (new Function() 문자를 객체화) <br/>
- 리터럴, 식별자, 표현식, 문
- 함수형 언어는 컴파일 언어가 아니기 때문에 평가/실행 시점으로 구분됨 <br/>
  (평가 단계가 컴파일임; 실행 컨텍스트의 메모리 확보 위함, 토크나이즈, <br/>
  선언문은 뭐든 간에 JS 엔진이 평가 시점에 위로 쫙 올려줌 <br/>
  const 상수는 미리 값 넣어줌 (static/cache 영역, 고정값, 별도의 공간에 있음, 실행 컨텍스트 말고 <br/>
  const 이용한 함수 표현식은 미리 값 안 넣어줌 <br/>
- const, let 도 호이스팅됨! (함수 블록 속에서)
- 메모리 외에 실행 컨텍스트라는 것이 있음
- JS 비동기 I/O 미리 보여주고 이후 처리
- cache 영역; 변하지 않으니 메모리에 미리 넣어 놓음
- lexical 정적이므로 평가 시점에서도 변수/함수 호이스팅 된 것 <br/>
  사이에 읽히는 순서대로 평가됨
- 함수 안에서 함수 밖에 것 접근 가능<br/>
  반대는 안됨
- 선언문은 static 영역에 잡힘, 함수 표현식은 heap 영역
- 클로저
- callee 부름 당하는 함수
- 매개변수 3개 이상이 되면 object 형태로 매개값 넘기는게 좋음
- side effect 발생 => 순수 함수가 아님 (바깥에 있는 것을 조작하면 안됨)
- 리액트는 무조건 순수함수임
- 보통 object는 함수에서 스프레드 문법 사용하고 { } 감싸서 받음 (얕은 복사/중간 복사)
- 시스템/소프트웨어 설계하는 패턴 (디자인 패턴)
- 디자인 패턴의 가장 중요한 목적은 소통을 위함
- 옵저버 패턴
